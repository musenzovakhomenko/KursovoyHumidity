== Пояснительная записка к курсовому проекту

= Тема: _Разработка устройства измерения влажности почвы_

=== _Выполнили студенты группы КЭ-413: Мусензова А.А. Хоменко Л.А._

== Задание:

Разработать устройство измерения влажности почвы. Для работы использовать отладочную
плату _XNUCLEO-F411RE_. Для измерения должен использоваться встроенный АЦП
микроконтроллера STM32F411.Получение кодов АЦП производить механизмом DMA.
Период измерения должен составлять 100 мс.

Для измерения влажности использовать
датчик влажности почвы _Moisture Sensor_. Погрешность измерения влажности почвы
не должна превышать 5% в диапазоне от 0 до 60%.
К измеренному значению должен быть применен цифровой фильтр.

Передача значений по
беспроводному интерфейсу должна осуществляться через модуль _BlueTooth Bee HC-06_
или _I/O Expansion Shield_. Для этого общение с платой должно осуществляться через
 USART2. Данные должны выводиться в формате: _"Влажность почвы: ХХХ.ХХ"_.

Архитектура программы представленна в видее UML диаграмм в пакете StarUML.Приложение
должно быть написано на языке С+ с использованием компилятора ARM 8.40.2.
При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++
обертка над ней.

== Выполнение работы:

=== Разработка общей архитектуры программмы

_Архитектура программного обеспечения_ — совокупность важнейших
решений об организации программной системы.
Архитектура включает:

* Выбор структурных элементов и их интерфейсов, с помощью которых составлена система,
а также их поведения в рамках сотрудничества структурных элементов;
* Соединение выбранных элементов структуры и поведения во всё более крупные системы;
* Архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы,
их сотрудничество и их соединение.

Для реализации устройства измерения влажности почвы, необходимо продумать и реализавать
архитектуру программного обеспечения данного устройства в соответствии с требованиями,
приведенными в задании. Изучив необходимые требования к устройству была разработана
архитектура программного обеспечения устройства. Она приведена на рисунке ниже.

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/All.jpg[]

Данная архитектура имеет две активные задачи: _HumidityTask_ и _BlueToothTask_. Они наследуют
обертку операционной системы реального времени _FreeRTOS_ — _Thread_.

_HumidityTask_ это активная задача,которая выполняется под руководством операционной
системы реального времени.Данная задача выполняет функцию измерения влажности почвы. Для этого
она раз в 100мс обращается к классу _Humidity_ и вызывает его для произвеления измерений.

Класс _Humidity_ выполняет преобразование отфильтрованных кодов АЦП в процентное значение
влажности. Для выпонения данной операции класс _Humidity_ обращается за отфильтрованными
значениями к классу _Filter_, а для получения текущих значений кодов АЦП к интерфейсу
_IDataSource_, который предаставляет значения, находящиеся в классе _ADC_.

Класс _Filter_ получает входной код, производит его фильтрацию и возвращает отфильтрованное
значение кода.

_IDataSource_ — это интерфейс, который предоставляет доступ к данным, получаемым с помощью АЦП.

Класс _ADC_ производит преобразование сигнала, получаемого с датчика влажности _Moisture Sensor_,
в цифровой вид, удобный для дальнейшего использования и преобразования.

_BlueToothTask_ - это активная задача,которая производит запрос данных у _HumidityTask_ и реализует
их отправку пользователю по интерфейсу BlueTooth c частотой один раз в 1000 мс в требуемом формате.
Для преобразования данных в требуемый формат задача обращается к классу _BlueTooth_.

Класс _BlueTooth_ производит преобразование данных, которые получены с _HumidityTask_ в
формат необходимый пользователю: _"Влажность почвы: ХХХ.ХХ"_. После произведенного преобразования
начинается отправка преобразованных даннных через интерфейс USART. За отправку сообщения по USART
отвечает класс _DriverUSART_.

Класс _DriverUSART_ - это класс, в котором реализуются функции отправки собщения, а также происходит
передача каждого последующего байта данных до окончания отправляемого сообщения. Для произведения
отправки сообщения необходимо включить передачу данных.За это отвечает класс _USART_.

Класс _USART_ позволяет записать в массив данные, которые необходимо передать, а также выполняет
включение передачи данных.

Таким образом, разработанная нами архитектура, позволяет выполнять поставленную задачу измерения
влажности почвы, соответствуя требованиям, выдвинутым в задании. Следующим этапом работы
является детальная разработка архитектуры каждого класса и написание рабочего кода.

=== Класс _USART_

Класс _USART_ включает в себя 4 метода. Каждый из них реализует определенную задачу.
Класс содержит в себе шаблон _TUSARTReg_.Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль USART1, так и USART2 не внося
изменения в код программы.
Опишем каждый метод класса подробнее:

* Метод _WriteByte()_ производит запись данных, которые необходимо отправить, в регистр данных _DR_
микроконтроллера, а также ждет, пока не запишутся все данные, так как длина посылаемого сообщения
может изменяться.

* Метод _EnableTransmit()_ включает передачу данных путем установления бита _TE_  регистра _CR1_
в 1.

* Метод _SetSpeed()_ устанавливает скорость передачи данных по _USART_. Скорость может быть
различной. Она расчитывается по формуле: _СLK/(BaudRate*8*(2-OVER8))_, где

- _СLK_ - значение тактовой частоты микроконтроллера в герцах.
- _BaudRate_ - значение скорости передачи, которое необходимо установить.
- _OVER8_ - режим дискретизации (при установлении 1/16 записывается 0, а при установлении 1/8 - 1).

Затем полученное значение записывается в регистр _BRR_.

* Метод _DisableTransmit()_ производит выключение передачи данных. Для этого бит _TE_  регистра _CR1_
устанавливается в 0.

Архитектура класса _USART_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/USART%20arch.jpg[]

Код класса _USART_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdint> // for uint8_t
//#include "itransmit.h" // for transmit


template <typename TUSARTReg>
class USART
 {
   public:
   void WriteByte (std::uint8_t byte) //записывает данные в регистр DR
    {
      TUSARTReg::DR::Write(byte);
      while(!TUSARTReg::SR::TXE::DataRegisterEmpty::IsSet())//ждем пока данные записываются
       {
       }
    }

   void EnableTransmit() //включает передачу данных
    {
      TUSARTReg::CR1::TE::Enable::Set();
    }

   void SetSpeed (std::uint16_t speed) // устанавливает скорость передачи данных
    {
      speed = (8'000'000/(9600*8*(2 - 0))) << 4U;
      TUSARTReg::BRR::Write(speed);
    }

   void DisableTransmit() //выключает передачу данных
    {
      TUSARTReg::CR1::TE::Disable::Set();
    }
 }
----

=== Класс _DriverUSART_

Клас _DrivrerUSART_ в своем составе имеет 3 метода. Данный класс содержит в себе ссылку
на класс _USART_. Он реализуется с помощью шаблона _aUsart_.

* Метод _SendMessage()_ реализует в себе включение передачи и отправку сообщения. В нем происходит
запись данных в масив, который формирует сообщение. Размер массива должен составлять не более 250
байт.Затем включается передача данных и происходит отправка сообщения.

* Метод _OnNextByteTransmit()_ производит передачу каждого последующего байта данных. Данная
операция происходит до окончания массива с данными. Затем передача выключается.

* Метод _SetSpeed()_ записывает значение скорости передачи данных по USART.

Архитектура класса _DriverUSART_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/DriverUSART.jpg[]

Код класса _DriverUSART_ представлен ниже:

[,cpp]
----
#pragma once
#include <array>
#include <cassert>

template <auto& aUsart>
class DriverUSART
 {
   public:
   void SendMessage (const char* message, std:: size_t aSize)//включение передачи и отправка сообщения
    {
       assert(size <= 255);
       size = aSize;
       memcpy(transmitBuffer, message, size);
       OnNextByteTransmit();
       aUsart.EnableTransmit();
    }

   void OnNextByteTransmit()//передача каждого следующего байта данных
    {
      aUsart.WriteByte(transmitBuffer[i++]);
      if( i > size)
        {
          aUsart.DisableTransmit();
          i=0U;
        }
    }

   void SetSpeed(std::uint32_t speed)//записывает значение скорости передачи данных USART
   {
     aUsart.SetSpeed(speed);
   }

   private:
   std::size_t i=0U;
   std::uint8_t transmitBuffer[255];
   size_t size = 0U;
 };
----

=== Класс _BlueTooth_

Класс _BlueTooth_ содержит в себе один метод.Так же как и предыдущий,
данный класс содержит в себе ссылку
на класс _DriverUSART_. Он реализуется с помощью шаблона _aDriverUsart_.

* Метод _DataTransmit_ производит преобразование данных, в вид, требуемый пользователем и
начинает отправку сообщения. Для этого метод преобразует данные, полученные от класса _BlueToothTask_,
в строку и преобразует их в вид: _Влажность почвы: ХХХ.ХХ_ и затем начинает отправку сформированного
сообщения.

Архитектура класса _BlueTooth_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/BlueTooth.jpg[]

Код класса _BlueTooth_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdio>
#include <iostream>

template <auto& aDriverUsart>
class BlueTooth
 {
   public:
   void DataTransmit(float value)
    {
      char str[30];
      sprintf(str, "Влажность почвы: %3.2f", value);
      aDriverUsart.SendMessage(str, strlen(str));
    }
 };
----

=== Класс _BlueToothTask_

Класс _BlueToothTask_ является активной задачей. Поэтому корректнее всего разделить его два файла
на файл где производится описание данного класса (файл _BlueToothTask.h_) и на файл, где описывается
реализация данного класса (файл _BlueToothTask.cpp_). Данный класс производит запрос данных для передачи
у _HumidityTask_ раз в 1000 мс, затем происходит событие - передача данных. Затем задача
переходит в спящий режим на 1000 мс.

Архитектура класса _BlueToothTask_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/BlueToothTask.jpg[]

Рассмотрим файл описания данного класса - файл _BlueToothTask.h_
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _BlueToothTask_ содержит метод _Execute()_ и конструктор _BlueToothTask()_.
Реализация метода _Execute()_ приведена в файле _BlueToothTask.cpp_.

Код файла _BlueToothTask.h_ представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "usart2registers.hpp"
#include "chrono"
#include "event.hpp"

using namespace OsWrapper;


class BlueToothTask : public Thread<128U>
 {
   public:
   void Execute();
   BlueToothTask();
 };
----

Рассмотрим файл реализации данного класса  - _BlueToothTask.cpp_.
Здесь класс _BlueToothTask_ содержит реализацию метода _Execute()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется получение значения с _HumidityTask_
и производится отправка полученного сообщения. Затем задача переходит в спящий режим на 1000 мс.

Код файла _BlueToothTask.срр_ представлен ниже:

[,cpp]
----
li,uiyjtrg
----

=== Класс _ADC_

Класс _ADC_ отвечает за настройку работы АЦП через модуль DMA, а также возвращает полученный код.
Он содержит в себе шаблон _TDMA_. Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль DMA1, так и DMA2 не внося
изменения в код программы.
Данный класс содержит в себе два метода:

* Конструктор _ADC()_ производит настройку работы АЦП. Первым делом подается тактирование на модуль DMA.
Затем для корректной работы DMA указывпем адрес периферии с которой требуется получать данные, потом
задаем адрес памяти в которой будут сохраняться полученные данные. Укажем направление передачи данных
в данном случае направление передачи из периферии в память. Затем необходимо указать количество посылаемых
сообщений, так как производится одно измерение будет посылаться одно сообщение. Затем укажем размерность данных
периферии и данных памяти. Они составят 16 бит. Установим приоритет преобразования - очень высокий.
Разрешим работу DMA в циклическом режиме и работу 0 канала DMA. Запустим АЦП на преобразование.

* Метод _GetCode()_ возвращает полученное с АЦП значение кода.

Архитектура класса _ADC_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/ADC.jpg[]

Код класса _ADC_ представлен ниже:

[,cpp]
----
#pragma once
#include "rccregisters.hpp" // for RCC
#include "adc1registers.hpp"// for ADC

template<typename TDMA>
class ADC
 {
   public:
   ADC()
    {
      RCC::AHB1ENR::DMA2EN::Enable::Set();// разрешение тактирования для DMA2
      TDMA::S0CR::EN::Disable::Set();
      TDMA::S0PAR::Write(ADC1::DR::Address);// указываем адрес периферии
      TDMA::S0M0AR::Write(reinterpret_cast<std::uintptr_t>(&Code));//задаем адрес памяти
      TDMA::S0CR::DIR::Peripheraltomemory::Set(); //указываем направление передачи данных из переферии в память
      TDMA::S0NDTR::Write(1U); // количество пересылаемых сообщений
      TDMA::S0CR::PSIZE::Bit16::Set();// размерность данных периферии
      TDMA::S0CR::MSIZE::Bit16::Set();// размерность данных памяти
      TDMA::S0CR::PL::VeryHigh::Set();//приоритет - очень высокий
      TDMA::S0CR::CIRC::Enable::Set();//разрешаем работу dma в циклическом режиме
      TDMA::S0CR::EN::Enable::Set();//разрешаем работу 0 канала dma
      ADC1::CR2::SWSTART::On::Set();
    }

   uint32_t GetCode()
    {
      return Code;
    }

   private:
   std::uint32_t Code;
 };
----

=== Класс _IDataSourse_

Класс _IDataSourse_ является интерфейсом. Он предоставляет доступ к данным из АЦП.
В своем составе он имеет один абстрактный метод.

* Абстрактный метод _GetCode()_ позволяет классу _Humidity_ получить доступ к данным, получаемым
при помощи АЦП и хранящимся к классе _ADC_.

Архитектура класса _IDataSourse_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/IDataSource.jpg[]

Код класса _IDataSourse_ представлен ниже:

[,cpp]
----
#pragma once

class IDataSource
 {
   public:
   virtual void GetCode() = 0;
 };
----

=== Класс _Filter_

Данный класс производит фильтрацию кодов АЦП. Он включает в себя два метода:

* Метод _Filter()_ является конструктором. В нем производится расчет постоянной фильтрации _tau_.
Она рассчитывается по формуле: _tau = 1-exp(-dt/RC)_, где

** _dt_ - это шаг дисретизации (выбрано значение равное 100),
** _RC_ - это постоянная времени (выбрано значение равное 1000).

Данная формула задана в техническом задании.

* Метод _Filtration()_ производит фильтрацию входного кода и возвращает отфильтрованное значение кода.
Отфильтрованное значение рассчитывается по формуле: _oldValue = oldValue + (Value - oldValue)*tau_, где

** _oldValue_ - хранит предыдущее отфильтрованное значение,
** _Value_ - хранит текущее значение кодов АЦП.

Данная формула задана в техническом задании.

Архитектура класса _Filter_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Filter.jpg[]

Код класса _Filter_ представлен ниже:

[,cpp]
----
#pragma once

class Filter
 {
   public:
   Filter()
   {
     tau = float(1.0f - exp(-(dt)/(RC))); // формула для фильтрации
   };

   uint32_t Filtration(const uint32_t Value) //Value - текущее измеренное значение влажности
   {
     oldValue = oldValue + (Value - oldValue)*tau;
     return oldValue;
   };

   private:
   float oldValue; //хранит предыдущее отфильтрованное значение
   float tau; //постоянная фильтрации
   static constexpr float dt = 100.0f; //шаг дискретизации
   static constexpr float RC = 1000.0f; //постоянная времени
 };
----

=== Класс _Humidity_

Этот класс рассчитывает значение по полученным из АЦП данным. В нем содержится два метода.
Данный класс содержит в себе ссылки на классы  _Filter_ и _IDataSource_. Они реализуются с помощью
шаблонов _aFilter_ и _DataSource_ соответственно. Рассмотрим каждый их методов в отдельности.

* Метод _ValueFiltration()_ производит фильтрацию полученных данных. Для этого он сначала получает данные
с АЦП, а затем фильтрует их с помощью фильтра.

* Метод _Calculate()_ производит преобразование отфильтрованных данных из АЦП в процентное значение
влажности. Для этого метод сначала получает отфильтрованные данные, а затем производит из расчет
используя полином пятой степени. Формирование полинома пятой степени производилось опытным путем. Был
произведен замер кодов в зависимости от влажности почвы с шагом 10%. Для этого была подготовленна сухая
почва массой 100 грамм. Затем были проведены замеры влажности в сухой почве, и в почве содержащей в себе
10% массы воды от всей массы почвы. Далее процентное содержание массы воды каждый раз увеличивалось на 10%.
Измерения проводились до содержание влажности в почве 60%, так как при повышение влажности более этого
значения коды АЦП выводились некорректно. Результаты измерений приведены в таблице ниже.

Таблица - Результаты полученных данных
|=======================================================
| Влажность почвы, %|Код АЦП
|          0        |  181
|          10       |  352
|          20       |  1168
|          30       |  1577
|          40       |  2012
|          50       |  2251
|          60       |  2420
|=======================================================

Для обработки полученных результатов и расчета по ним полинома был использован сервис _WolframAlpha_.
Результаты расчетов в данном сервисе приведены на рисунках ниже.

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wolfram_1.jpg[]

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wolfram_2.jpg[]


Таким образом, был получен полином: 1.50821*10^-14^*x^5^-1.02856*10^-10^*x^4^+2.64864*10^-7^*x^3^-
0.000309566*x^2^+0.172643*x-22.5334 по которому и производился расчет. Вместо х используется отфильтрованное
значение АЦП. В конце метод возвращает рассчитанное значение влажности.

Архитектура класса _Humidity_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Humidity.jpg[]

Код класса _Humidity_ представлен ниже:

[,cpp]
----
#pragma once
#include "Filter.h"
#include "IDataSource.h"
#include <iostream>

template <auto& aFilter, auto& DataSource>

class Humidity
 {
   public:
   float Calculate()
    {
      ValueFiltration();
      CalculateData = ((1.50821*(pow(10,(-14))))*(pow (FiltredValue,5)))-((1.02856*(pow(10,(-10))))*(pow(FiltredValue,4)))+((2.64864*(pow(10,(-7))))*(pow(FiltredValue,3)))-((0.000309566)*(pow(FiltredValue,2)))+(0.172643*FiltredValue)-22.5334;
      return CalculateData;
    }

   void ValueFiltration()
    {
       Value = DataSource.GetCode();
       FiltredValue = aFilter.Filtration(Value);
    }

   private:
   uint16_t Value;
   uint16_t FiltredValue;
   float CalculateData;
 };
----

=== Класс _HumidityTask_

Класс _HumidityTask_ также, как и _BlueToothTask_ является активной задачей. Поэтому также разделим его на два файла
файл _HumidityTask.h_ и на файл _HumidityTask.cpp_. Данный класс производит расчет значения влажности по кодам
АЦП и переходит в спящий режим на 100 мс.

Архитектура класса _HumidityTask_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/HumidityTask.jpg[]

Рассмотрим файл описания данного класса - файл _HumidityTask.h_.
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _HumidityTask_ содержит метод _Execute()_ и конструктор _HumidityTask()_.
Реализация метода _Execute()_ приведена в файле _HumidityTask.cpp_.

Код файла _HumidityTask.h_. представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "usart2registers.hpp"
#include "chrono"
#include "event.hpp"

using namespace OsWrapper;


class BlueToothTask : public Thread<128U>
 {
   public:
   void Execute();
   HumidityTask();
 };
----

Рассмотрим файл реализации данного класса  - _HumidityTask.cpp_.
Здесь класс _HumidityTask_ содержит реализацию метода _Execute()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется расчет значений
кодов АЦП во влажность. Затем задача переходит в спящий режим на 100 мс.

Код файла _HumidityTask.cpp_ представлен ниже:

[,cpp]
----
#include "HumidityTask.h"
#include "Humidity.h"
#include "IDataSource.h"
#include "Filter.h"
#include "ADC.h"
#include "dma2registers.hpp"

extern ADC<DMA2> adc;
extern Filter filter;
extern Humidity<filter, adc> humidity;


void HumidityTask::Execute()
 {
   for(;;)
    {
      humidity.Calculate();
      Sleep(100ms);
    }
}
----


















