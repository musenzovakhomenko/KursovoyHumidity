== Пояснительная записка к курсовому проекту

= Тема: _Разработка устройства измерения влажности почвы_

=== _Выполнили студенты группы КЭ-413: Мусензова А.А. Хоменко Л.А._

== Задание:

Разработать устройство измерения влажности почвы. Для работы использовать отладочную
плату _XNUCLEO-F411RE_. Для измерения должен использоваться встроенный АЦП
микроконтроллера STM32F411.Получение кодов АЦП производить механизмом DMA.
Период измерения должен составлять 100 мс.

Для измерения влажности использовать
датчик влажности почвы _Moisture Sensor_. Погрешность измерения влажности почвы
не должна превышать 5% в диапазоне от 0 до 60%.
К измеренному значению должен быть применен цифровой фильтр.

Передача значений по
беспроводному интерфейсу должна осуществляться через модуль _BlueTooth Bee HC-06_
или _I/O Expansion Shield_. Для этого общение с платой должно осуществляться через
 USART2. Данные должны выводиться в формате: _"Влажность почвы: ХХХ.ХХ"_.

Архитектура программы представленна в видее UML диаграмм в пакете StarUML.Приложение
должно быть написано на языке С+ с использованием компилятора ARM 8.40.2.
При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++
обертка над ней.

== Введение

Программное обеспечение (ПО) — программа или множество программ, используемых
для управления компьютером.

Программное обеспечение является одним из видов обеспечения вычислительной системы,
наряду с техническим (аппаратным), математическим, информационным, лингвистическим,
организационным и методическим обеспечением.

=== Микроконтроллер _STM32F411RE_ и отладочная плата на его базе

Для разработки должна использоваться отладочная плата _XNUCLEO-F411RE_ на базе микроконтроллера
_STM32F411RE_.

_XNUCLEO-F411RE_ – отладочная плата компании Waveshare представляет собой усовершенствованную
версию платы _NUCLEO-F411RE_ семейства _STM32 NUCLEO_ компании _ST Microelectronics_. В основе
платы _ARM Cortex-M4_ микроконтроллер _STM32F411RET6_. Изделие поддерживает легкое подключение плат
функционального расширения _Arduino_. Таким образом, имеется доступ к огромным ресурсам _Arduino_.

Разъемы _ST Morpho_ платы _XNUCLEO-F411RE_ обеспечивают полный доступ к линиям портов ввода/вывода
_(I/O)_ и дальнейшее периферийное расширение.

Поддержка _mbed_ делает возможным быстрое построение
прототипа устройства с использованием _SDK_ и _online_ инструментов.
Комплексное бесплатное программное обеспечение (HAL библиотека) включает различные примеры
софта. Изделие поставляется с отдельным модулем _ST-Link/ V2_. _Mbed_ – программно-аппаратная
платформа и одноимённая операционная система для устройств на базе 32-разрядных
микроконтроллеров семейства _ARM Cortex-M_. Проект был запущен компанией _ARM_ совместно
с другими производителями полупроводников. Платформа работает онлайн и содержит интегрированную
среду разработки _(IDE)_ включая текстовый редактор, компилятор, набор библиотек
и примеры программного кода. К аппаратной части относятся платы от _ARM_, семейства плат _mbed_
и _FRDM_ от _NXP_ Semiconductors, семейство _Nucleo_ от _STMicroelectronics_, семейство _EFM32_ от
_Silicon Labs_ и многие другие.

Отличительной чертой _mbed_ является вариант работы, при котором программист не нуждается в
инсталляции специального инструментария для
программирования контроллеров. В этом варианте для написания кода используется онлайн _IDE_,
работающая через браузер. Компиляция также производится онлайн. Облачное хранение кода
поддержано онлайн системой контроля версий _Mercurial_. Программист скачивает на свой компьютер
уже двоичный исполняемый файл, который может тут же загрузить на одну из поддерживаемых плат.
На некоторых из предлагаемых плат установлен USB-загрузчик, имитирующий флешку: запись файла
на эту флешку приводит к прошивке программной памяти микроконтролера. Таким образом,
программист не нуждается ни в каких специальных программных или аппаратных инструментах,
а работа может быть выполнена даже на планшете.

Разрабатываемое устройство должно быть реализовано на базе микроконтроллера. В качестве него
выберем _STM32F411RE_. Рассмотрим характеристики микроконтроллера _STM32F411RE_.

Отличительные особенности _STM32F411RE_:

* 32-битное ядро _ARM® Cortex™-M4_ с блоком DSP-вычислений с плавающей точкой
(FPU), адаптивным ускорителем реального времени (ART Accelerator™),
обеспечивающим исполнение инструкций из памяти программ с нулевым ожиданием;
* Режим пакетного сбора данных _(BAM)_, позволяющий уменьшить энергопотребление
в процессе пакетной обработки данных;
* До 512 Кбайт _FLASH-памяти_;
* 128 Кбайт _SRAM-памяти_;
* Система тактирования, управления сбросом и питания;
* Диапазон напряжения питания и напряжения на линиях ввода/вывода: от 1.7 В до 3.6 В
* Режим сброса при включении _(POR)_, выключении _(PDR)_ питания, программируемый детектор
напряжения _(PVD)_ и сброс при переходе в ждущий режим _(BOR)_
* Кварцевый генератор с частотой от 4 до 26 МГц
* Внутренний RC-генератор с частотой 16 МГц с заводской калибровкой
* Генератор с частотой 32 кГц и калибровкой для тактирования часов реального времени
* Внутренний RC-генератор с частотой 32 кГц и калибровкой;
* Один 12-битный АЦП с частотой дискретизации 2.4 MSPS (млн. выб/с): до 16 каналов;
* Контроллер прямого доступа к памяти _(DMA)_ общего назначения: 16 каналов с поддержкой режима
_FIFO_ и переполнения;
* До 11 таймеров: до шести 16-битных, два 32-битных таймера с тактовой частотой 100 МГц,
каждый с четырьмя каналами захвата и сравнения входа/выхода (IC/OC)/ШИМ или счётчиком импульсов,
входом квадратурного кодера (с увеличением счёта), два сторожевых таймера (независимый и
системный), а также системный таймер _SysTick_;
* Отладочные интерфейсы _SWD_ и _JTAG_;
* До 81 линии ввода/вывода с функцией прерывания;
* До 13 коммуникационных интерфейсов;
* Три _I2C_ (SMBus/PMBus);
* Три _USART_ (2 x 12.5 Мбит/с, 1 x 6.25 Мбит/с), интерфейс стандарта _ISO 7816_, порт сети _LIN_,
модулятор инфракрасного порта и управление модемом;
* Пять _SPI/I2S_ (до 50 Мбит/с, _SPI_ или _I2S_ аудиопротокол), _SPI2_ и _SPI3_ с
мультиплексированием и полнодуплексной передачей _I2S_ для достижения точности
аудиокласса посредством внутреннего аудиогенератора с фазовой автоподстройкой частоты или
внешнего тактового генератора;
* Часы реального времени: точность менее 1 сек., аппаратный блок календаря;

Область применения данного микроконтроллера включает в себя:

* Управление двигателями;
* Медицинское оборудование;
* Промышленные устройства: программируемые логические контроллеры, инверторы и прерыватели цепей;
* Принтеры и сканеры;
* Системы сигнализации;
* Переговорные видеоустройства;
* Системы климат-контроля;
* Бытовая аудиотехника;
* Концентратор датчиков мобильных телефонов.

=== Датчик измерения влажности

Для измерения влажности почвы в работе используетcя датчик влажности _Moisture Sensor_ производителя
WaveShare, который входит в набор _XNUCLEO-F411RE Pakage A_.
Этот модуль представляет собой блок усиления тока транзистором.
Когда воды в почве достаточно для проведения тока
между основанием и положительно заряженным элементом,
между основанием и эмиттером генерируется определенное количество тока.
И в то же время электрический ток вырабатывается с опредЭто беспроводной модуль _Bluetooth_, который обеспечивает
простой интерфейс для подключения к _Arduino_ ,
_Firewing_ и другим приложениям микроконтроллеров.
Модуль предоставляет способ
беспроводного подключения к ПК или телефону _Bluetooth_ для
передачи/приема встроенных данных, таких как
данные _GPS_, показания напряжения АЦП и другие параметры.еленным коэффициентом усиления
между коллектором и эмиттером и подается на резистор в эмиттере для создания напряжения.
Затем это напряжение преобразуется с помощью аналого-цифрового преобразователя.

===  _BlueTooth_ модуль

Передача данных осуществляется с помощью модуля _BlueTooth Bee V2.0_ производителя _ElecFreaks_.
Данный беспроводной модуль  обеспечивает
простой интерфейс для подключения к различным приложениям микроконтроллеров.
Модуль предоставляет способ беспроводного подключения к ПК или телефону для
передачи/приема встроенных данных, таких как
данные GPS, показания напряжения АЦП и другие параметры.

* Напряжение питания может составлять от 3,6 до 6 В постоянного тока.
* Модуль легко подключается к любому стандартному устройству Bluetooth, необходимо найти
и ввести код доступа "1234".
* Скорость передачи данных составляет 38400 бит/с.
* Модуль не требует дополнительной настройки.

=== UML-диаграммы

_Унифицированный язык моделирования (Unified Modeling Language, UML)_ является графическим
языком для визуализации, специфицирования, конструирования и документирования систем,
в которых большая роль принадлежит программному обеспечению.

С помощью _UML_ можно детально описать систему, начиная разработку с концептуальной модели с ее
бизнес - функциями и процессами, а также описать
особенности реализации системы, такие как классы программного обеспечения системы, схему базы
данных. Используя UML, мы также можем разрабатывать сложные системы быстро и качественно.

Как язык графического визуального моделирования _UML_ имеет свою нотацию – принятые обозначения.
Нотация обеспечивает семантику языка, является способом унификации обозначений визуального
моделирования, обеспечивает всестороннее представление системы, которое сравнительно легко
и свободно воспринимается человеком.

Моделирование с помощью _UML_ осуществляется поэтапным построением ряда диаграмм, каждая
из которых отражает какую-то часть или сторону системы либо ее замысла.

Диаграмма – это графическое представление множества элементов. Обычно диаграмма
изображается в виде графа с вершинами (сущностями) и ребрами (отношениями).
Диаграммы подчиняются нотации _UML_ и изображаются в соответствии с ней.
Основные диаграммы _UML_:

* вариантов использования (use case diagram);
* классов (class diagram);
* кооперации (collaboration diagram);
* последовательности (sequence diagram);
* состояний (statechart diagram);
* деятельности (activity diagram);
* компонентов (component diagram);
* развертывания (deployment diagram).

Построения этих диаграмм достаточно для полного моделирования системы.

_StarUML_ поддерживает одиннадцать различных типов диаграмм, принятых в
нотации _UML_, а также подход _MDA_ (модельно – настраиваемая архитектура),
предлагает настройку параметров пользователя для адаптации среды разработки,
поддерживает расширения, предоставляет различного рода модули, расширяющие
возможности StarUML.

Концепция _MDA (Model Driven Architecture)_ призвана обеспечить общую основу для описания и
использования большинства существующих стандартов, не ограничивая разработчиков в выборе
конкретных технологий. Интеграция стандартов достигается за счет: введения концепции
платформно-независимой модели приложения; использования унифицированного инструмента
для описания таких моделей.

Опишем основные элементы нотации _UML_.

* _Класс_ – это описание группы объектов с общими свойствами (атрибутами), поведением (операциями),
отношениями с другими объектами и семантикой.
Каждый класс является шаблоном для создания объекта. А каждый объект – это экземпляр класса.
Каждый объект может быть экземпляром только одного класса.
Имя атрибута может быть произвольной текстовой строкой. Имя является единственным обязательным
элементом при задании атрибута.

* _Видимость(visibility)_ — качественная характеристика описания свойств класса,
характеризующая потенциальную возможность других объектов модели использовать это
свойство (атрибут или операцию).
Видимость в языке UML обозначается с помощью квантора видимости (visibility),
который может принимать одно из 4-х возможных значений и отображаться при помощи
специальных символов.

** _Открытый (public)_ атрибут виден всем остальным классам. Любой класс, связанный
с данным в рамках диаграммы или пакета, может просмотреть или изменить значение атрибута.
Обозначается символом «+» перед именем атрибута.

** _Защищенный (protected)_. Любой потомок данного класса может пользоваться его защищенными
свойствами. Обозначается знаком «#» перед именем атрибута.

** _Закрытый (private)_. Атрибут с этой областью видимости недоступен или не виден для
всех классов без исключения.Обозначается знаком «-» перед именем атрибута.

** _Пакетный (package)_. Атрибут является открытым, но только в пределах своего пакета.
В StarUML данный атрибут обозначается значком «~»

* Ассоциация – это семантическая связь между классами. На диаграмме ее рисуют в виде
обычной линии. Ассоциация может быть однонаправленной или двунаправленной. В первом
случае ее изображают в виде стрелки, показывающей направление связи. Во втором случае –
двойной стрелки либо просто линии без стрелок.
Если между классами создана двунаправленная связь, то каждый из них видит открытые атрибуты
и операции других классов.

* Агрегация – специальная форма ассоциации, которая служит для представления отношения типа
"часть - целое" между агрегатом (целое) и его составной частью.

* Композицией называется форма агрегирования с четко выраженным отношением владения,
причем время жизни частей и целого совпадают.
Как только будет уничтожен объект целое, так вместе с ним будет уничтожен объект часть.
На диаграммах композиция показывается также, как и агрегация, но только
ромб должен быть закрашен.


* Обобщение – это отношение наследования между двумя элементами модели.
Оно дает классу возможность наследовать открытые или защищенные атрибуты и операции
суперкласса (класса от которого наследуются атрибуты и операции). Помимо наследуемых
каждый класс может иметь свои атрибуты и операции.
На диаграммах обобщение изображается в виде стрелки с не закрашенным треугольником у
суперкласса, идущей от потомка.

=== Язык программирования С++

Язык программирования — формальный язык, предназначенный для записи компьютерных программ.
Язык программирования определяет набор лексических, синтаксических и семантических правил,
определяющих внешний вид программы и действия, которые выполнит исполнитель под её управлением.

C++  — компилируемый, статически типизированный язык программирования
общего назначения, на котором можно создавать программы любого уровня сложности.

В процессе работы разработчик получает абсолютную свободу в выборе инструментов для
того, чтобы задача, решаемая с помощью того или иного подхода, была решена максимально
эффективно. Иными словами, С++ не понуждает программиста придерживаться только одного стиля
разработки программы (например, объектно-ориентированного).

Синтаксис C++ унаследован от языка C. Одним из принципов разработки было
сохранение совместимости с C. Тем не менее, C++ не является в строгом смысле
надмножеством C.
C++ повлиял на многие языки программирования, в их числе: Java, C#, D.
C++ имеет богатую стандартную библиотеку, которая включает в себя распространённые
контейнеры и алгоритмы, ввод-вывод, регулярные выражения, поддержку многопоточности
и другие возможности.

=== Среда разработки IAR Embedded Workbench

IAR Embedded Workbench – это интегрированная отладочная среда разработки приложений _(IDE)_,
обладающая рядом неоспоримых преимуществ. К ним относятся удобный пользовательский интерфейс,
генерирование компактного объектного кода, поддержка различных типов _RTOS_ (Micrium μC/OS,II,
OSEC ORTI) и _JTAG-адаптеров_ третьих фирм (OLIMEX, Phyton, ASHLING), а также
подробная техническая документация. Компания _IAR Systems_ поставляет _IDE_ для широкого
спектра 8-, 16-, 32-разрядных микропроцессоров таких фирм, как _ARM_, _Infineon_, _Cypress_,
_Atmel_, _Analog Devices_, _Microchip Technologies_, _Ember_, _NXP_, _National Semiconductor_,
_STMicroelectronics_, _Texas Instruments_, _Renesas_, _Freescale_, _Silicon Labs_ и др.

Типовой комплект IAR Embedded Workbench содержит: C/C++ компилятор,
транслятор языка ассемблера, компоновщик, управляющие программы для работы
с библиотечными подпрограммами, редактор, менеджер проектов, C-SPY отладчик.
Для большинства IDE поставка возможна в трех вариантах: Standard (полная профессиональная
версия), Baseline (ограничения на объем генерируемого кода, отсутствие годовой
технической поддержки) или Limited (не входят C-SPY отладчик, RTOS-модули, отсутствует
поддержка MISRA C).

=== Операционная Система Реального Времени _FreeRTOS_

_FreeRTOS_ – многозадачная операционная система реального времени (ОСРВ) для
встраиваемых систем. Портирована на 35 микропроцессорных архитектур. Распространяется
под модифицированной лицензией _GPL_ с исключением,
позволяющим разработчику присвоить модифицированный код операционной системы.

_Операцио́нная систе́ма  (англ. operating system, OS)_ –
комплекс взаимосвязанных программ, предназначенных для управления ресурсами компьютера
и организации взаимодействия с пользователем.

_Операционная система реального времени, ОСРВ (англ. real-time operating system, RTOS)_
– тип операционной системы, основное назначение которой – предоставление необходимого
и достаточного набора функций для работы систем реального времени на конкретном
аппаратном оборудовании.

Операционные системы реального времени _(ОСРВ(RTOS))_ предназначены для обеспечения
интерфейса к ресурсам критических по времени систем реального времени. Основной задачей
в таких системах является своевременность _(timeliness)_ выполнения обработки данных.

Задачей _ОСРВ_ является обеспечение реакции на определенное действие за отведенный квант времени.

Для разных задач такой квант может иметь разное значение, например, для обработки.
Приблизительное время реакции в зависимости от области применения _ОСРВ_ может быть следующее:

* математическое моделирование - несколько микросекунд
* радиолокация – несколько миллисекунд
* складской учет – несколько секунд
* управление производством - несколько минут

=== Измерение влажности и его методы

Основной показатель присутствия влаги в почве – влажность.
Это процентное соотношение воды и сухой массы в грунте. Методы вычисления влажности
классифицируются на несколько групп:

* Первая – изъятие образцов земли и измерение влажности в лабораторных условиях.
* Вторая – использование приборов, установленных в грунте при естественном залегании.

Влага – основной фактор, оказывающий влияние на плодородность земли.
Влажность почвы определяют для того, чтобы узнать:

* количество содержания влаги в земле;
* структуру грунта: плотность, эластичность;
* какие удобрения необходимы для грунта;
* какая культура может выращиваться на определенном участке;
* предупредить выветривание земли из-за чрезмерной сухости;
* определить способность грунта к сельскохозяйственным, агротехническим процессам.

Существует 5 способов проверки количества воды в грунте. Самые популярные из них:

* _Гравиметрические_ – основаны на получении воды из грунта посредством химической реакции
и испарения. Более точные результаты достигаются с использованием сушильной емкости.
* _Электромагнитные_ – связаны с действием влажности на электрические характеристики земли.
Существует множество сенсоров, реагирующие на поляризацию, сопротивление или на два свойства
одновременно. Приборы широко используются для определения влаги в верхнем слое, при глубинных
исследованиях четкая корреляция отсутствует.
* _Микроволновые_ – базируется на низкой тепло- и электропроводности воды, характеристики
излучения связаны с влагоемкостью. Минус – высокая цена приборов.
* _Тензометрический_ – основан на возможности грунта впитывать влажность.
Устройства определяют колебания влагоемкости земли. Ноль означает, что грунт насыщен водой.
* _Термический_ – связан с тепловой инерцией почвы, ее влажности. Диагностика выполняется
посредством портативных приборов.


== Анализ требований

По требованиям проекта разработка устройства должна производиться на отладочной плате _XNUCLEO-F411RE_,
котрая в своем составе содержит микроконтроллер _STM32F411RE_. Описание и основные характеристики
микроконтроллера описаны выше. Отладочная плата обладает возможностью дополнительного расширения
ее функционала в зависимости от поставленной задачи. Всю работу разрабатываемого устройство можно
разделить на две основные задачи - измерение влажности и отправление данных. Проанализируем требования
для каждой из задач:

* _Задача измерения влажности_.

По техническому заданию считывание данных по АЦП должно производиться через модуль _DMA_. Модуль _DMA_, так
же как и АЦП являются встроенными в выбранный микроконтроллер.

АЦП - это устройство  используемое для связи первичных преобразователей величин (электрических
и неэлектрических) микропроцессорами или другими устройствами, обеспечивающими накопление и обработку
результатов измерения.

Аналого-цифровым преобразованием является процесс, при котором входная величина, преимущественно
физическая преобразуется в соответствующее числовое значение. Таким образом, аналого-цифровой
преобразователь является устройством, которое выполняет это преобразование. То есть на входе, могут
быть такие величины как ток, напряжение, сопротивление, емкость, угол поворота.
Аналого-цифровой преобразователь обладает многими характеристиками. К основным из них можно
отнести разрядность и частоту преобразования. Частота преобразования измеряется в отсчетах в секунду,
а разрядность в битах. Эти две величины связанны друг с другом: чем больше значение эффективной
разрядности, тем меньше частота преобразования.

Модуль _DMA_ - это блок прямого доступа к памяти (ПДП). Его суть заключается в том, чтобы по команде
от периферии или ядра взять и скопировать часть памяти с одного места на другой. Во время этой
операции основной процессор может выполнять другие задачи, прерываясь только в том случае, когда
транзакция закончилась и новый блок данных целиком доступен для обработки. Большие объемы данных
могут быть переданы без значительного ухудшения общей производительности системы.

DMA в основном
используется для реализации центрального буферизированного хранилища (обычно в system SRAM) для
различных модулей периферийных устройств. Это решение менее дорогое в контексте использования
микросхем и потребления энергии в сравнении с другими распространенными решениями, где каждое
периферийное устройство требует создания собственного локального хранилища данных.

Для использования АЦП через модуль DMA необходимо:

** Подключить АЦП и _DMA_ к шине тактирования
** Настроить порты, по которым будут сниматься данные в альтернативный режим
** Устанавить разрядность АЦП
** Выбирать тип преобразования АЦП
** Устанавить количество измерений АЦП
** Выбирать канал, по которому будет производиться измерение АЦП
** Устанавлить скорость дискретизации АЦП
** Указать адрес переферии для модуля _DMA_
** Задать адрес памяти для модуля _DMA_
** Указать направление передачи данных из переферии в память
** Указать количество посылаемых сообщений
** Указать размерность данных переферии и памяти
** Устанавить приоритет
** Устанавить режим работы модуля _DMA_
** Разрешить работу выбранного канала _DMA_
** Запустить АЦП на преобразование
** Включить считывание по _DMA_
** Включить АЦП

Перед дальнейшей обработкой, данные, полученные с АЦП должны быть отфильтрованы с использованием цифрового
фидьтра. Условия, которым должен удовлетворять цифровой фильтр представлены в техническом задании.

В качестве датчика влажности выбран датчик _Moisture sensor_ производителя _Waveshare_. Для корректного
получения данных с датчика необходимо произвести его калибровку. Для произведения калибровки были произведены
опытные измерения. Их суть заключается в том, что был
произведен замер кодов в зависимости от влажности почвы с шагом 10%, а после это проведена обработка
полученных значений и сформирован полином, по которому производится преобразование
полученных кодов АЦП в процентное значение влажности. Для этого была подготовленна сухая
почва массой 100 грамм. Затем были проведены замеры влажности в сухой почве, и в почве содержащей в себе
10% массы воды от всей массы почвы. Далее процентное содержание массы воды каждый раз увеличивалось на 10%.
Измерения проводились до содержания влажности в почве 60%, так как при повышение влажности более этого
значения коды АЦП выводились некорректно. Результаты измерений приведены в таблице ниже.

Таблица - Результаты полученных данных
|=======================================================
| Влажность почвы, %|Код АЦП
|          0        |  181
|          10       |  352
|          20       |  1168
|          30       |  1577
|          40       |  2012
|          50       |  2251
|          60       |  2420
|=======================================================

Для обработки полученных результатов и расчета по ним полинома был использован сервис _WolframAlpha_.

Произведем расчет полиномов 3, 4, 5 степени и определим наиболее подходящий.

Рассчитаем полином _3 степени_. Результат приведем на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wf_3_1.jpg[]

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wf_3_2.jpg[]

Произведем рассчет полинома _4 степени_ и приведем результат ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wf_4_1.jpg[]

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wf_4_2.jpg[]

Рассчитаем полином _5 степени_ на данном сервисе  и приведем получившийся результат на рисунках ниже.

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wolfram_1.jpg[]

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Wolfram_2.jpg[]

По результатам рассчетов можно сделать вывод о том, что наиболее подходящим полиномом
является полином _5 степени_, так как его графическая  характеристика больше всего
удовлетворяет калибровачным точкам.

Таким образом, был получен полином: 1.50821*10^-14^*x^5^-1.02856*10^-10^*x^4^+2.64864*10^-7^*x^3^-
0.000309566*x^2^+0.172643*x-22.5334 по которому и будет производиться расчет влажности.

На этом этапе завершается измерение влажности.

* _Задача отправления данных пользователю_

Отправление данных пользователю должно осуществляться по беспроводному интерфейсу _BlueTooth_.
_Bluetooth_ — это беспроводная персональная сеть передачи данных, которая используется для
сопряжения устройств, оснащенных специальными модулями. В основном его используют для того,
чтобы передать те или иные данные с одного устройства на другое.
Так же можно управлять устройствами на расстоянии без  проводов, соединять несколько
устройств на достаточно большом расстоянии (до 100 метров).
Для этого в работе выбран специальный  _BlueTooth_ модуль _BlueTooth Bee V2.0_ производителя _ElecFreaks_.
Его характеристики приведены выше.

Для передачи данных _BlueTooth_ модуль должен получать преобразованые данные влажности. Поэтому для
обмена данными между микроконтроллером и _BlueTooth_ модулем необходимо воспользоваться
универсальным синхронно-ассинхронным приемопередатчиком _(USART)_.

Универсальный синхронно-асинхронный приёмопередатчик — узел вычислительных устройств,
предназначенный для организации связи с другими цифровыми устройствами. Преобразует передаваемые
данные в последовательный вид так, чтобы было возможно передать их по одной физической цифровой
линии другому аналогичному устройству. Данный метод преобразования хорошо стандартизован и широко
применяется в компьютерной технике. Передача данных в _USART_ осуществляется по одному биту в равные
промежутки времени. Этот временной промежуток определяется заданной скоростью _USART_.
В выбранном микроконтроллере данный модуль является встроенным.

Перед отправкой данных пользователю, необходимо сформировать требуемое сообщение. Для этого создается
массив данных, который выглядит следующим образом: _Влажность почвы: ХХХ.ХХ_.

Для реализации отправки сформированного собщения необходимо сконфигурировать модуль USART.
Для этого необходимо:

** Подключить к шине тактирования модуль _USART_
** Настроить порты на альтернативную функцию работы с нужным модулем _USART_
** Настроить формат передачи данных
** Задать скорость передачи данных
** задать количество стоп битов,проверку четности
** Установить режим дескритизации
** Установить длину слова
** Разрешить передачу данных
** включить модуль _USART_

Таким образом будет происходить обмен данными между платой и _BlueTooth_ модулем, а с помощью
_BlueTooth_ модуля будет производиться передача данных пользователю в заданном формате.


Архитектура программы должна быть представленна в виде UML диаграмм.Приложение должно быть написано на языке
С++ с использованием IAR Embedded Workbench for arm 8.40.2. Программа должна быть разработа
с использованием Операционной системы реального времени. Описание выбора продуктов для
реализации данных требований задания приведены выше.



== Общая архитектуры программмы

_Архитектура программного обеспечения_ — совокупность важнейших
решений об организации программной системы.
Архитектура включает:

* Выбор структурных элементов и их интерфейсов, с помощью которых составлена система,
а также их поведения в рамках сотрудничества структурных элементов;
* Соединение выбранных элементов структуры и поведения во всё более крупные системы;
* Архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы,
их сотрудничество и их соединение.

Для реализации устройства измерения влажности почвы, необходимо продумать и реализавать
архитектуру программного обеспечения данного устройства в соответствии с требованиями,
приведенными в задании. Изучив необходимые требования к устройству была разработана
архитектура программного обеспечения устройства. Она приведена на рисунке ниже.

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/ALLL.png[]

Данная архитектура имеет две активные задачи: _HumidityTask_ и _BlueToothTask_. Они наследуют
обертку операционной системы реального времени _FreeRTOS_ — _Thread_.

_HumidityTask_ это активная задача,которая выполняется под руководством операционной
системы реального времени.Данная задача выполняет функцию измерения влажности почвы. Для этого
она раз в 100мс обращается к классу _Humidity_ и вызывает его для произвеления измерений.

Класс _Humidity_ выполняет преобразование отфильтрованных кодов АЦП в процентное значение
влажности. Для выпонения данной операции класс _Humidity_ обращается за отфильтрованными
значениями к классу _Filter_, а для получения текущих значений кодов АЦП к интерфейсу
_IDataSource_, который предаставляет значения, находящиеся в классе _ADC_.

Класс _Filter_ получает входной код, производит его фильтрацию и возвращает отфильтрованное
значение кода.

_IDataSource_ — это интерфейс, который предоставляет доступ к данным, получаемым с помощью АЦП.

Класс _ADC_ производит преобразование сигнала, получаемого с датчика влажности _Moisture Sensor_,
в цифровой вид, удобный для дальнейшего использования и преобразования.

_BlueToothTask_ - это активная задача,которая производит запрос данных у _HumidityTask_ и реализует
их отправку пользователю по интерфейсу BlueTooth c частотой один раз в 1000 мс в требуемом формате.
Для преобразования данных в требуемый формат задача обращается к классу _BlueTooth_.

Класс _BlueTooth_ производит преобразование данных, которые получены с _HumidityTask_ в
формат необходимый пользователю: _"Влажность почвы: ХХХ.ХХ"_. После произведенного преобразования
начинается отправка преобразованных даннных через интерфейс USART. За отправку сообщения по USART
отвечает класс _DriverUSART_.

Класс _DriverUSART_ - это класс, в котором реализуются функции отправки собщения, а также происходит
передача каждого последующего байта данных до окончания отправляемого сообщения. Для произведения
отправки сообщения необходимо включить передачу данных.За это отвечает класс _USART_.

Класс _USART_ позволяет записать в массив данные, которые необходимо передать, а также выполняет
включение передачи данных.

Таким образом, разработанная нами архитектура, позволяет выполнять поставленную задачу измерения
влажности почвы, соответствуя требованиям, выдвинутым в задании. Следующим этапом работы
является детальная разработка архитектуры каждого класса и написание рабочего кода.


== Детальная архитектура программы

Детальная архитектура программы включает в себя подробное описание каждолго класса, а также находящихся в
нем методов и их взаиможействие друг с другом.

=== Класс _USART_

Класс _USART_ включает в себя 4 метода. Каждый из них реализует определенную задачу.
Класс содержит в себе шаблон _TUSARTReg_.Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль USART1, так и USART2 не внося
изменения в код программы.
Опишем каждый метод класса подробнее:

* Метод _WriteByte()_ производит запись данных, которые необходимо отправить, в регистр данных _DR_
микроконтроллера, а также ждет, пока не запишутся все данные, так как длина посылаемого сообщения
может изменяться.

* Метод _EnableTransmit()_ включает передачу данных путем установления бита _TE_  регистра _CR1_
в 1.

* Метод _SetSpeed()_ устанавливает скорость передачи данных по _USART_. Скорость может быть
различной. Она расчитывается по формуле: _СLK/(BaudRate*8*(2-OVER8))_, где

- _СLK_ - значение тактовой частоты микроконтроллера в герцах.
- _BaudRate_ - значение скорости передачи, которое необходимо установить.
- _OVER8_ - режим дискретизации (при установлении 1/16 записывается 0, а при установлении 1/8 - 1).

Затем полученное значение записывается в регистр _BRR_.

* Метод _DisableTransmit()_ производит выключение передачи данных. Для этого бит _TE_  регистра _CR1_
устанавливается в 0.

Архитектура класса _USART_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/USART%20arch.jpg[]

Код класса _USART_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdint> // for uint8_t
//#include "itransmit.h" // for transmit


template <typename TUSARTReg>
class USART
 {
   public:
   void WriteByte (std::uint8_t byte) //записывает данные в регистр DR
    {
      TUSARTReg::DR::Write(byte);
      while(!TUSARTReg::SR::TXE::DataRegisterEmpty::IsSet())//ждем пока данные записываются
       {
       }
    }

   void EnableTransmit() //включает передачу данных
    {
      TUSARTReg::CR1::TE::Enable::Set();
    }

   void SetSpeed (std::uint16_t speed) // устанавливает скорость передачи данных
    {
      speed = (8'000'000/(9600*8*(2 - 0))) << 4U;
      TUSARTReg::BRR::Write(speed);
    }

   void DisableTransmit() //выключает передачу данных
    {
      TUSARTReg::CR1::TE::Disable::Set();
    }
 }
----

=== Класс _DriverUSART_

Клас _DrivrerUSART_ в своем составе имеет 3 метода. Данный класс содержит в себе ссылку
на класс _USART_. Он реализуется с помощью шаблона _aUsart_.

* Метод _SendMessage()_ реализует в себе включение передачи и отправку сообщения. В нем происходит
запись данных в массив, который формирует сообщение. Размер массива должен составлять не более 255
байт.Затем включается передача данных, в цикле передается каждый символ и
происходит отправка сообщения. После этого передача выключается.

* Метод _OnNextByteTransmit()_ производит запись данных в буфер для дальнейшей передачи.

* Метод _SetSpeed()_ записывает значение скорости передачи данных по USART.

Архитектура класса _DriverUSART_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/DriverUSART.jpg[]

Код класса _DriverUSART_ представлен ниже:

[,cpp]
----
#include <cassert>
#include "USART.h" // for oUsart

template <auto& aUsart>
class  DriverUSART
 {
   public:
   void SendMessage (const char* message, std:: size_t aSize)//включение передачи и отправка сообщения
    {
      assert(size <= 255);
      size = aSize;
      memcpy(transmitBuffer, message, size);
      i=0U;
      aUsart.EnableTransmit();
      for(int j=0; j < size+1; j++)
      {
       OnNextByteTransmit();
      }
      aUsart.DisableTransmit();
    }

   void OnNextByteTransmit()//передача каждошо следующего байта данных
    {
      aUsart.WriteByte(transmitBuffer[i++]);
    }

   void SetSpeed(std::uint32_t speed)//записывает значение скорости передачи данных USART
   {
     aUsart.SetSpeed(speed);
   }

   private:
   std::size_t i=0U;
   std::uint8_t transmitBuffer[255]={};
   size_t size = 0U;
 };

inline DriverUSART<oUsart> usartDriver;
----

=== Класс _BlueTooth_

Класс _BlueTooth_ содержит в себе один метод.Так же как и предыдущий,
данный класс содержит в себе ссылку
на класс _DriverUSART_. Он реализуется с помощью шаблона _aDriverUsart_.

* Метод _DataTransmit_ производит преобразование данных, в вид, требуемый пользователем и
начинает отправку сообщения. Для этого метод преобразует данные, полученные от класса _BlueToothTask_,
в строку и преобразует их в вид: _Влажность почвы: ХХХ.ХХ_ и затем начинает отправку сформированного
сообщения.

Архитектура класса _BlueTooth_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/BlueTooth.jpg[]

Код класса _BlueTooth_ представлен ниже:

[,cpp]
----
#pragma once
#include <cstdio>
#include <iostream>

template <auto& aDriverUsart>
class BlueTooth
 {
   public:
   void DataTransmit(float value)
    {
      char str[30] = {};
      sprintf(str, " Влажность почвы: %3.2f \n", value);
      aDriverUsart.SendMessage(str, strlen(str));
    }
 };
----

=== Класс _BlueToothTask_

Класс _BlueToothTask_ является активной задачей. Поэтому корректнее всего разделить его два файла
на файл где производится описание данного класса (файл _BlueToothTask.h_) и на файл, где описывается
реализация данного класса (файл _BlueToothTask.cpp_). Данный класс производит запрос данных для передачи
у _HumidityTask_ раз в 1000 мс, затем происходит событие - передача данных. Затем задача
переходит в спящий режим на 1000 мс.

Архитектура класса _BlueToothTask_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/BTTask.jpg[]

Рассмотрим файл описания данного класса - файл _BlueToothTask.h_
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _BlueToothTask_ содержит метод _Execute()_ и конструктор _BlueToothTask()_.
Реализация метода _Execute()_ приведена в файле _BlueToothTask.cpp_.

Код файла _BlueToothTask.h_ представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "usart2registers.hpp"
#include "chrono"
#include "event.hpp"

using namespace OsWrapper;


class BlueToothTask : public Thread<128U>
 {
   public:
   void Execute();
   BlueToothTask();
 };
----

Рассмотрим файл реализации данного класса  - _BlueToothTask.cpp_.
Здесь класс _BlueToothTask_ содержит реализацию метода _Execute()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется получение значения с _HumidityTask_
и производится отправка полученного сообщения. Затем задача переходит в спящий режим на 1000 мс.
Конструктор _BlueToothTask()_ позволяет обратиться к классу _HumidityTask_.

Код файла _BlueToothTask.срр_ представлен ниже:

[,cpp]
----
#include "BlueToothTask.h"
#include "BlueTooth.h"
#include "DriverUsart.h"
#include "USART.h"

void BlueToothTask::Execute()
{
  for(;;)
   {
    bluetooth.DataTransmit(humidity.GetValueHumidity());
    Sleep(1000ms);
   }
}

BlueToothTask::BlueToothTask(HumidityTask& _humidity) : humidity(_humidity)
{
}
----

=== Класс _ADC_

Класс _ADC_ отвечает за настройку работы АЦП через модуль DMA, а также возвращает полученный код.
Он содержит в себе шаблон _TDMA_. Он позволяет сделать код данного класса более универсальным.
Подключая различные библиотечные файлы можно настроить на работу как модуль DMA1, так и DMA2 не внося
изменения в код программы.
Данный класс содержит в себе два метода:

* Конструктор _ADC()_ производит настройку работы АЦП. Первым делом подается тактирование на модуль DMA.
Затем для корректной работы DMA указывпем адрес периферии с которой требуется получать данные, потом
задаем адрес памяти в которой будут сохраняться полученные данные. Укажем направление передачи данных
в данном случае направление передачи из периферии в память. Затем необходимо указать количество посылаемых
сообщений, так как производится одно измерение будет посылаться одно сообщение. Затем укажем размерность данных
периферии и данных памяти. Они составят 16 бит. Установим приоритет преобразования - очень высокий.
Разрешим работу DMA в циклическом режиме и работу 0 канала DMA. Запустим АЦП на преобразование.

* Метод _GetCode()_ возвращает полученное с АЦП значение кода.

Архитектура класса _ADC_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/ADC.jpg[]

Код класса _ADC_ представлен ниже:

[,cpp]
----
#pragma once
#include "rccregisters.hpp" // for RCC
#include "adc1registers.hpp"// for ADC

template<typename TDMA>
class ADC
 {
   public:
   ADC()
    {
      RCC::AHB1ENR::DMA2EN::Enable::Set();// разрешение тактирования для DMA2
      TDMA::S0CR::EN::Disable::Set();
      TDMA::S0PAR::Write(ADC1::DR::Address);// указываем адрес периферии
      TDMA::S0M0AR::Write(reinterpret_cast<std::uintptr_t>(&Code));//задаем адрес памяти
      TDMA::S0CR::DIR::Peripheraltomemory::Set(); //указываем направление передачи данных из переферии в память
      TDMA::S0NDTR::Write(1U); // количество пересылаемых сообщений
      TDMA::S0CR::PSIZE::Bit16::Set();// размерность данных периферии
      TDMA::S0CR::MSIZE::Bit16::Set();// размерность данных памяти
      TDMA::S0CR::PL::VeryHigh::Set();//приоритет - очень высокий
      TDMA::S0CR::CIRC::Enable::Set();//разрешаем работу dma в циклическом режиме
      TDMA::S0CR::EN::Enable::Set();//разрешаем работу 0 канала dma
      ADC1::CR2::SWSTART::On::Set();
    }

   uint32_t GetCode()
    {
      return Code;
    }

   private:
   std::uint32_t Code;
 };
----

=== Класс _IDataSourse_

Класс _IDataSourse_ является интерфейсом. Он предоставляет доступ к данным из АЦП.
В своем составе он имеет один абстрактный метод.

* Абстрактный метод _GetCode()_ позволяет классу _Humidity_ получить доступ к данным, получаемым
при помощи АЦП и хранящимся к классе _ADC_.

Архитектура класса _IDataSourse_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/IDataSource.jpg[]

Код класса _IDataSourse_ представлен ниже:

[,cpp]
----
#pragma once

class IDataSource
 {
   public:
   virtual void GetCode() = 0;
 };
----

=== Класс _Filter_

Данный класс производит фильтрацию кодов АЦП. Он включает в себя два метода:

* Метод _Filter()_ является конструктором. В нем производится расчет постоянной фильтрации _tau_.
Она рассчитывается по формуле: _tau = 1-exp(-dt/RC)_, где

** _dt_ - это шаг дисретизации (выбрано значение равное 100),
** _RC_ - это постоянная времени (выбрано значение равное 1000).

Данная формула задана в техническом задании.

* Метод _Filtration()_ производит фильтрацию входного кода и возвращает отфильтрованное значение кода.
Отфильтрованное значение рассчитывается по формуле: _oldValue = oldValue + (Value - oldValue)*tau_, где

** _oldValue_ - хранит предыдущее отфильтрованное значение,
** _Value_ - хранит текущее значение кодов АЦП.

Данная формула задана в техническом задании.

Архитектура класса _Filter_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Filter.jpg[]

Код класса _Filter_ представлен ниже:

[,cpp]
----
#pragma once

class Filter
 {
   public:
   Filter()
   {
     tau = float(1.0f - exp(-(dt)/(RC))); // формула для фильтрации
   };

   uint32_t Filtration(const uint32_t Value) //Value - текущее измеренное значение влажности
   {
     oldValue = oldValue + (Value - oldValue)*tau;
     return oldValue;
   };

   private:
   float oldValue; //хранит предыдущее отфильтрованное значение
   float tau; //постоянная фильтрации
   static constexpr float dt = 100.0f; //шаг дискретизации
   static constexpr float RC = 1000.0f; //постоянная времени
 };
----

=== Класс _Humidity_

Этот класс рассчитывает значение по полученным из АЦП данным. В нем содержится два метода.
Данный класс содержит в себе ссылки на классы  _Filter_ и _IDataSource_. Они реализуются с помощью
шаблонов _aFilter_ и _DataSource_ соответственно. Рассмотрим каждый их методов в отдельности.

* Метод _GetValue()_ возвращает отфильтрованные и расчитанные данные.

* Метод _Calculate()_ производит преобразование отфильтрованных данных из АЦП в процентное значение
влажности. Для этого метод сначала получает данные с АЦП и производит их фильтрацию.
После фильтрации данных производит из расчет
используя полином пятой степени: 1.50821*10^-14^*x^5^-1.02856*10^-10^*x^4^+2.64864*10^-7^*x^3^-
0.000309566*x^2^+0.172643*x-22.5334 по которому и производился расчет. Вместо _х_ используется отфильтрованное
значение АЦП.

Архитектура класса _Humidity_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Hum.jpg[]

Код класса _Humidity_ представлен ниже:

[,cpp]
----
#pragma once
#include "Filter.h"
#include "IDataSource.h"
#include <iostream>

template <auto& aFilter, auto& DataSource>

class Humidity
 {
   public:
    void Calculate()
   {
     float FiltredValue = aFilter.Filtration(DataSource.GetCode());
     Value = ((1.50821*(pow(10,(-14))))*(pow (FiltredValue,5)))-((1.02856*(pow(10,(-10))))*(pow(FiltredValue,4)))+((2.64864*(pow(10,(-7))))*(pow(FiltredValue,3)))-((0.000309566)*(pow(FiltredValue,2)))+(0.172643*FiltredValue)-22.5334;
   }

  float GetValue()
  {
    Calculate();
    if(Value<0)
    {
      Value=0;
    }
     return Value;
  }

 private:
  float Value;
 };
----

=== Класс _HumidityTask_

Класс _HumidityTask_ также, как и _BlueToothTask_ является активной задачей. Поэтому также разделим его на два файла
файл _HumidityTask.h_ и на файл _HumidityTask.cpp_. Данный класс производит расчет значения влажности по кодам
АЦП и переходит в спящий режим на 100 мс.

Архитектура класса _HumidityTask_ представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/HumTask.jpg[]

Рассмотрим файл описания данного класса - файл _HumidityTask.h_.
Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.
Класс _HumidityTask_ содержит метод _Execute()_ , метод _GetValueHumidity()_ и конструктор _HumidityTask()_.
Реализация методов _Execute()_ и _GetValueHumidity()_ приведена в файле _HumidityTask.cpp_.

Код файла _HumidityTask.h_. представлен ниже:

[,cpp]
----
#pragma once
#include "thread.hpp"
#include <cstdio>
#include <iostream>
#include "rccregisters.hpp"
#include "adc1registers.hpp"
#include "chrono"
#include "event.hpp"
#include "HumidityTask.h"
#include "Humidity.h"
#include "Filter.h"
#include "ADC.h"
#include "dma2registers.hpp"

using namespace OsWrapper;


class HumidityTask : public Thread<128U>
 {
   public:
   void Execute();
   HumidityTask() = default;
   float GetValueHumidity();

 private:
   Humidity<filter, adc> humidity;
 };
----

Рассмотрим файл реализации данного класса  - _HumidityTask.cpp_.
Здесь класс _HumidityTask_ содержит реализацию метода _Execute()_ и _GetValueHumidity()_.
Метод _Execute()_ включает в себя бесконечный цикл. В нем реализуется расчет значений
кодов АЦП во влажность. Затем задача переходит в спящий режим на 100 мс.
Метод _GetValueHumidity()_ возвращает расчитанное и отфильтрованное значение влажности.

Код файла _HumidityTask.cpp_ представлен ниже:

[,cpp]
----
#include "HumidityTask.h"
#include "Humidity.h"
#include "IDataSource.h"
#include "Filter.h"
#include "ADC.h"
#include "dma2registers.hpp"


extern ADC<DMA2> adc;
extern Filter filter;
extern Humidity<filter, adc> humidity;


void HumidityTask::Execute()
{
  for(;;)
   {
    GetValueHumidity();
    Sleep(100ms);
   }
}

float HumidityTask::GetValueHumidity()
{
  return humidity.GetValue();
}
----


=== Основной код

Основной код программы и основные настройки необходимых элементов приведены в файле _main.cpp_.
В коде программы находится функция ___low_level_init_ в ней происходит основная настройка элементов:

- подключение микроконтроллера к внешнему источнику питания;
- подключение модулей _USART_ и ножку канала, по которому производится измерение влажности, и модуля АЦП
к шине тактирования;
- Производится основная настройка модуля _USART_ (выбираем длину слова, режим дискретизации,
проверку четности, включаем модуль и включаем передачу);
- Производится настройка модуля АЦП (устанавливаем разрядность,непрерывное преобразование,
выбираем количество измерений, канал преобразования, скорость дискретизации, включаем модуль _DMA_,
включаем АЦП)

Затем создадим объекты классов _HumidityTask_ и _BlueToothTask_.

Так как устройство работает под управлением операционной системы реального времени FreeRTOS
введем пространство имен OsWrapper.

В функции _main()_ произведем настройку скорости передачи данных по _USART_. Для этого
используем функцию _SetSpeed()_ установим значение 38 400U, так как с данной скоростью происходит обмен
данными по выбранному BlueTooth модулю.
Затем создадим два потока данных под управлением операционной системы реального времени.
Один из потоков производит измерение влажности и в нем реализуется активная задача _HumidityTask_,
а второй - отправку измеренных данных,  нем реализуется задача _BlueToothTask_.
Они имеют нормальный приоритет выполнения.
Затем производится запуск операционной системы реального времени.

Код файла _main.cpp_ представлен ниже:

[,cpp]
----
#include "rtos.hpp"         // for Rtos
#include "mailbox.hpp"      // for Mailbox
#include "event.hpp"        // for Event
#include <iostream>
#include "rccregisters.hpp" // for RCC
#include <gpioaregisters.hpp>  // for GPIOA
#include <gpiocregisters.hpp>  // for GPIOC
#include "BlueToothTask.h"
#include "adc1registers.hpp"
#include "HumidityTask.h"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
int __low_level_init(void)
   {
     RCC::CR::HSEON::On::Set();
     while(!RCC::CR::HSERDY::Ready::IsSet())
      {
      }

     RCC::CFGR::SW::Hse::Set();

     while(!RCC::CFGR::SWS::Hse::IsSet())
      {
      }

     RCC::CR::HSION::Off::Set();

     RCC::AHB1ENR::GPIOAEN::Enable::Set();
     GPIOA::MODER::MODER0::Analog::Set();
     RCC::APB1ENR::USART2EN::Enable::Set(); //K ISTOCHNIKY TAKTIROVANIYA
     GPIOA::OTYPER::OT2::OutputPushPull::Set();
     GPIOA::PUPDR::PUPDR3::PullUp::Set();
     GPIOA::AFRL::AFRL2::Af7::Set();
     USART2::CR1::M::Data8bits::Set(); //8 bit dlina slova
     USART2::CR1::OVER8::OversamplingBy16::Set(); //rezhim diskretizacii
     USART2::CR2::STOP::Value0::Set();
     USART2::CR1::PS::ParityEven::Set(); //bez proverki chetnosti
     USART2::CR1::UE::Enable::Set(); //vkl usart
     USART2::CR1::TE::Enable::Set(); //vlk peredacha

     RCC::APB2ENR::ADC1EN::Enable::Set();//подключаем ацп к шине тактирования
     ADC1::CR1::RES::Bits12::Set(); // установим разрядность ацп
     ADC1::CR2::CONT::ContinuousConversion::Set(); // непрерывное преобразование
     ADC1::SQR1::L::Conversions1::Set(); // установим количество измерений 1
     ADC1::SQR3::SQ3::Channel0::Set(); //выберем 0 канал
     ADC1::SMPR2::Write(4U); // скорость дискретизации
     ADC1::CR2::DMA::Enable::Set();//включение считывания по dma
     ADC1::CR2::DDS::DMARequest::Set();
     ADC1::CR2::ADON::Enable::Set(); // включаем ацп
     return 1;
   }
}


HumidityTask  humidity;
BlueToothTask bluetoothtask(humidity);

using namespace OsWrapper;

int main()
{
  usartDriver.SetSpeed(38400U);
  Rtos::CreateThread(humidity,"humidity", ThreadPriority::normal);
  Rtos::CreateThread(bluetoothtask, "bluetoothtask",ThreadPriority::normal);
  Rtos::Start();
  return 0;
}
----

== Вывод

В ходе работы было разработано устройство, позволяющее измерять
влажность почвы и передавать полученные данные пользователь по беспроводному
интерфейсу BlueTooth  формате "Влажность почвы: ХХХ.ХХ". Данное устройство обладает
всеми характеристиками, которые были заданы в техническом задании.

Отображение результата работы программы пользователю представлена на рисунке ниже:

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Data_1.jpg[]

image::https://github.com/musenzovakhomenko/KursovoyHumidity/blob/main/Data_2.jpg[]










